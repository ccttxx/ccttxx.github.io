<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进制的转换]]></title>
    <url>%2F2018%2F04%2F13%2F%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机进制转换]]></title>
    <url>%2F2018%2F04%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、概述1、数制：用一组固定的符号和统一的规则来表示数值的方法 2、计算机底层使用的述职是二进制 3、用Java编程使用的是十进制，而Java底层仍使用二进制 4、计算机常用的数制还有八进制和十六进制 二、十进制十进制的基本数字0~9，逢十进位。10称做“基数”，10^n（10的n次幂）被称作“权”。 10000＝1×10^4 1000＝1×10^3 100＝1×10^2 10＝1×10^1 1＝1×10^0 （1）十进制转二进制规律：不断除以2，保留余数，商为0时不再除2. 将所有余数倒序排列。 【示例】(13)10=(1101)2 （2）十进制转十六进制规律：不断除以16，保留余数，商为0时不再除16. 将所有余数倒序排序。 示例：(138)10=(8A)16 三、二进制二进制的基本数字是0、1，逢2进位。二进制的基数为2，权为2^n（2的n次方） 1＝1×2^0 10＝1×2^1 100＝1×2^2 1000＝1×2^3 10000＝1×2^4 100000＝1×2^5 1000000＝1×2^6 10000000＝1×2^7 示例：(1111)2=( __)10 答案：(1111)2=1×2^3+1×2^2+1×2^1+1×2^0=8+4+2+1=15 （1）二进制转十进制(10110)2=(_)10 解：1 2^4+1 2^2 + 1 * 21=(22)10 （2）二进制转十六进制规律：四位二进制数相当于一位十六进制数。 示例： (11010110)2=(_)16 解：1101 0110=(D6)16 四、八进制八进制的基本数字是0、1、2、3、4、5、6、7，逢8进位。八进制的基数为8，权为8^n（8的n次方） 1＝1×8^0 10＝1×8^1 100＝1×8^2 1000＝1×8^3 10000＝1×8^4 100000＝1×8^5 1000000＝1×8^6 10000000＝1×8^7 （1）二进制与八进制的互相转换二进制与八进制的互相转换和二进制与十六进制的转换类似，区别在于需要操作的是三位一组而不是四位。 五、十六进制十六进制的基本数字是0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F，逢16进位。十六进制的基数为16，权为16^n(16的n次方) （1）十六进制转换为十进制(41)16 =(__)10 解：4 16^1 + 1 16^0 =(65)10 (41)16= (__)2 解：(0100 0001)2 说明：16进制的1位数代表2进制的4位数。]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想——赋值]]></title>
    <url>%2F2017%2F09%2F20%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E2%80%94%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223package assignment1;class Number&#123; int i;&#125;public class Test &#123; public static void main(String[] args) &#123; Number n1 = new Number(); Number n2 = new Number(); n1.i = 9; n2.i = 47; System.out.println("n1:" + n1.i + "\n" + "n2:" + n2.i); n1 = n2; System.out.println("n1:" + n1.i + "\n" + "n2:" + n2.i); n1.i = 27; System.out.println("n1:" + n1.i + "\n" + "n2:" + n2.i); &#125; &#125; Number类的两个实例（n1和n2）是在main()里创建的。每个Number中的i值都赋予了一个不同的值。随后，将n2赋给n1，而且n1发生改变。 最后的结果为： 123456n1:9n2:47n1:47n2:47n1:27n2:27 看来改变n1的同时也改变了n2!这是由于无论n1还是n2都包含了相同的句柄，它指向相同的对象(最初 的句柄位于 n1 内部，指向容纳了值 9 的一个对象。在赋值过程中，那个句柄实际已经丢失;它的对象会由 “垃圾收集器”自动清除)。 这种特殊的现象通常也叫作“别名”，是 Java 操作对象的一种基本方式。但假若不愿意在这种情况下出现别 名，又该怎么操作呢?可放弃赋值，并写入下述代码:n1.i = n2.i; 代码如下： 123456789101112131415161718192021222324package assignment1;class Number&#123; int i;&#125;public class Test &#123; public static void main(String[] args) &#123; Number n1 = new Number(); Number n2 = new Number(); n1.i = 9; n2.i = 47; System.out.println(n1+","+n2); n1.i = n2.i; System.out.println(n1+","+n2); System.out.println("n1:" + n1.i + "\n" + "n2:" + n2.i); n1 = n2; System.out.println("n1:" + n1.i + "\n" + "n2:" + n2.i); System.out.println(n1+","+n2); &#125; &#125; 结果如下： 1234567assignment1.Number@7852e922,assignment1.Number@4e25154fassignment1.Number@7852e922,assignment1.Number@4e25154fn1:47n2:47n1:47n2:47assignment1.Number@4e25154f,assignment1.Number@4e25154f 从结果看出，使用n1.i = n2.i;后打印出来n1和n2的hashcode依然是不相同的，这样便可保留两个独立的对象，而不是将 n1 和 n2 绑定到相同的对象。但您很快就会意识到，这样做会使对 象内部的字段处理发生混乱，并与标准的面向对象设计准则相悖。 当新建n1和n2两个实例时，会存放在JVM的栈中，拥有独立的内存地址，而它们各自定义的变量会存放在堆中。所以，当执行n1 = n2时，两者的内存地址会相同，而各自变量的赋值不会对内存地址造成影响。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端返回html到后台转换成图片]]></title>
    <url>%2F2017%2F09%2F19%2F%E5%89%8D%E7%AB%AF%E8%BF%94%E5%9B%9Ehtml%E5%88%B0%E5%90%8E%E5%8F%B0%E8%BD%AC%E6%8D%A2%E6%88%90%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[Html转换成图片的步骤如下： 一、通过ajax把html传到后台二、分析html对应的外置css并作为行内样式写入字符串三、把处理后的图片转为图片一、通过ajax把html传到后台这个步骤大家都会，就忽略了 二、分析html对应的外置css并作为行内样式写入字符串在这里需要用到两个第三方jar包：CSSParser和jsoup 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 为html加上行内样式并返回文件名 * @param htmlStr * @return */public String turnReportToImg(String htmlStr,String color)&#123; //与表格相关的几个外置css File css1 = new File("report_style1.css"); File css2 = new File("bg_newsample_blue.css"); File css3 = new File("editcss.css"); File css4 = new File("css2.css"); ArrayList&lt;File&gt; files = new ArrayList&lt;File&gt;(); files.add(css1); files.add(css2); files.add(css3); files.add(css4); for (File file : files) &#123; try &#123; htmlStr = EditorChartUtil.inlineStyles(htmlStr, file, false); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return EditorChartUtil.convertImage(htmlStr,color);&#125; /** * 把外部css转化为html行内样式 * @param html * @param cssFile * @param removeClasses 是否去掉类名 * @return * @throws IOException */public static String inlineStyles(String html, File cssFile, boolean removeClasses) throws IOException &#123; Document document = Jsoup.parse(html); CSSOMParser parser = new CSSOMParser(); InputSource source = new InputSource(new FileReader(cssFile)); CSSStyleSheet stylesheet = parser.parseStyleSheet(source, null, null); CSSRuleList ruleList = stylesheet.getCssRules(); Map&lt;Element, Map&lt;String, String&gt;&gt; allElementsStyles = new HashMap&lt;&gt;(); for (int ruleIndex = 0; ruleIndex &lt; ruleList.getLength(); ruleIndex++) &#123; CSSRule item = ruleList.item(ruleIndex); if (item instanceof CSSStyleRule) &#123; CSSStyleRule styleRule = (CSSStyleRule) item; String cssSelector = styleRule.getSelectorText(); //不识别带: if(cssSelector.indexOf(":") != -1)&#123; cssSelector = cssSelector.substring(0, cssSelector.indexOf(":")); &#125; Elements elements = document.select(cssSelector); for (int elementIndex = 0; elementIndex &lt; elements.size(); elementIndex++) &#123; Element element = elements.get(elementIndex); Map&lt;String, String&gt; elementStyles = allElementsStyles.get(element); if (elementStyles == null) &#123; elementStyles = new LinkedHashMap&lt;String, String&gt;(); allElementsStyles.put(element, elementStyles); &#125; CSSStyleDeclaration style = styleRule.getStyle(); for (int propertyIndex = 0; propertyIndex &lt; style.getLength(); propertyIndex++) &#123; String propertyName = style.item(propertyIndex); String propertyValue = style.getPropertyValue(propertyName); elementStyles.put(propertyName, propertyValue); &#125; &#125; &#125; &#125; for (Map.Entry&lt;Element, Map&lt;String, String&gt;&gt; elementEntry : allElementsStyles.entrySet()) &#123; Element element = elementEntry.getKey(); StringBuilder builder = new StringBuilder(); for (Map.Entry&lt;String, String&gt; styleEntry : elementEntry.getValue().entrySet()) &#123; builder.append(styleEntry.getKey()).append(":").append(styleEntry.getValue()).append(";"); &#125; builder.append(element.attr("style")); element.attr("style", builder.toString()); if (removeClasses) &#123; element.removeAttr("class"); &#125; &#125; return document.html();&#125; 三、把处理后的图片转为图片在这一步骤中主要用到的第三方jar包为：html2image 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 把html转换为图片并返回文件名 * @param htmlStr * @return */public static String convertImage (String htmlStr, String color)&#123; HtmlImageGenerator imageGenerator = new HtmlImageGenerator(); color = getHex(color); htmlStr = replaceRgb(htmlStr).toString().replaceAll("#2cade2", color); imageGenerator.loadHtml(htmlStr); String imgPath = MediaUtil.getImgPath(); String ID = RandomGUID.getGUID(); String imgName = "table-" + ID + ".png"; imageGenerator.saveAsImage(imgPath+imgName); File f = new File(imgPath,imgName); if(f.exists())&#123; return imgName; &#125; return "";&#125;/** * 把rgb字符串转换为十六进制字符串 * @param s * @return */public static String getHex(String s) &#123; String hex = ""; s = s.substring(s.indexOf("rgb") + 4, s.indexOf(")")).replaceAll(" ", ""); String[] array = s.split(","); int r = Integer.parseInt(array[0]); int g = Integer.parseInt(array[1]); int b = Integer.parseInt(array[2]); hex += "#"; if (r &lt; 16) &#123; hex += "0"; &#125; hex += Integer.toHexString(r); if (g &lt; 16) &#123; hex += "0"; &#125; hex += Integer.toHexString(g); if (b &lt; 16) &#123; hex += "0"; &#125; hex += Integer.toHexString(b); return hex;&#125;/** * 把字符串中的rgb替换为十六进制，并返回字符串 * @param str * @return */public static StringBuffer replaceRgb(String str) &#123; String regex = "rgb\\((\\s*\\d&#123;1,3&#125;\\s*,)&#123;2&#125;\\s*\\d&#123;1,3&#125;\\s*\\)"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(str); StringBuffer sb = new StringBuffer(); while (matcher.find())&#123; String matchStr = matcher.group(); matcher.appendReplacement(sb, getHex(matchStr)); &#125; StringBuffer sb2 = matcher.appendTail(sb); return sb2;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端借助dom-to-image把HTML转成图片并通过ajax上传到服务器]]></title>
    <url>%2F2017%2F09%2F11%2F%E5%89%8D%E7%AB%AF%E5%80%9F%E5%8A%A9dom-to-image%E6%8A%8AHTML%E8%BD%AC%E6%88%90%E5%9B%BE%E7%89%87%E5%B9%B6%E9%80%9A%E8%BF%87ajax%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[之前接到了一个任务，把jsp中的table转成一个图片，保存在指定文件夹并显示在前端。 我的思路是： 一、引用第三方js在前端把table转成图片二、通过ajax把图片上传到服务器，保存在指定文件夹三、浏览器根据文件名从服务器端获取图片 一、引用第三方js在前端把table转成图片一开始我在百度找到了比较多人用过的html2canvas，据说很多坑，但由于这些坑都是几年前被发现的，我觉得现在更新了这么多个版本应该没啥问题了吧。考虑到稳定性，我下载了0.4.1版本，还真的有坑，只能把可视区域内的html给转换出来，毕竟我的表格数据多变，这种效果肯定是不行的。 经过了一轮的百度，我从一位大神的贴子中找到了解决方法，需要0.5.0版本，使用html2canvas实现浏览器截图。解决方法是修改一小段源码，通过设置截图区域的width和height来截取内容，于是我把width和height分别附上table的div的宽和高，出来的效果是——还是差一点，虽然能突破了只能在可视区域截取内容的障碍，但是再截图区域的宽高设置上还得手动给它加个几十像素去让它截取完整，这样肯定会出bug。 一番折腾后，我放弃了这个插件了，不好用。转战谷歌，看看有啥更好地第三方插件 功夫不负有心人，它就是——dom-to-image dom-to-image介绍这是一个与html2canvas功能差不多的第三方js插件，能够把dom节点转换为矢量图（svg）和位图（png和jpeg），完美解决了html2canvas出现过的坑。 使用的代码如下（转成png）： 1234567var node = document.getElementById('table');domtoimage.toPng(node).then(function (dataUrl) &#123; var img = new Image(); img.src = dataUrl; document.body.appendChild(img);&#125;); 无论我的表格有多大，它都能全部获取到，图片稍微失真。 二、通过ajax把图片上传到服务器，保存在指定文件夹我发现dom-to-image返回的png图片是通过Base64编码的，表现的方式基本如下： 1data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAsZCykDAREAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/ 需要在后台进行解码才能保存为文件（需要注意的是，把“data:image/jpeg;base64”去掉再进行解码，否则生成的文件会提示已损坏） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 转换url:data数据为正常图片 * @param dataUrl Base64编码的图片 * @return 返回文件名 */ public String getDataUrlPic(String dataUrl)&#123; String ID = RandomGUID.getGUID(); String imgName = "table-" + ID + ".png"; String imgPath = getImgPath(); if(GenerateImage(dataUrl,imgName,imgPath))&#123; return imgName; &#125; return ""; &#125;/** * 把转换后的图片存放到指定目录 * @param imgStr dataUrl * @param imgName 图片名称 * @param imgPath 存放路径 * @return */ public boolean generateImage(String imgStr,String imgName,String imgPath)&#123; //把“data:image/jpeg;base64”去掉, imgStr = imgStr.substring(imgStr.indexOf(",") + 1); if (imgStr == null) &#123; return false; &#125; BASE64Decoder decoder = new BASE64Decoder(); try &#123; // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) &#123; if (b[i] &lt; 0) &#123;// 调整异常数据 b[i] += 256; &#125; &#125; File headPath = new File(imgPath); if (!headPath.exists()) &#123; headPath.mkdirs(); &#125; String imgFilePath = imgPath + "/" + imgName; OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; 但是问题来了，当我的表格数据多的时候，发现导出来的图片已损坏。原因是字符串过长提交失败，网上的说法也不一致，有的说post限制2m的提交，要更改服务器配置（本人用的tomcat）；也有说post无限制，无需修改。修改配置的方法我试过，没效果，无需修改？明明不行啊…… 经过多次的尝试，我发现转成Blob图片后使用ajax传输到后台并不会出现上述问题。而且用原生的ajax并非jquery封装过的ajax，代码如下： 12345678910111213141516171819var node = document.getElementById('table'); var responseText; domtoimage.toBlob(node) .then(function (blob) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', '/test', true); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; responseText = xhr.responseText; if(responseText != "")&#123; //拼servlet地址放入img标签的src属性中 var reportUrl = "/EditorChartServlet?filename=" + responseText; $("img").attr("src",reportUrl); &#125; &#125; &#125;; xhr.setRequestHeader("Content-Type", "image/png"); xhr.send(blob); &#125;); 所以后台无需进行解码，而是在ajax里的url所请求的servlet中把Blob图片转存到指定文件夹中即可，servlet的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package ctx.ajax;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name = "TestUpload", urlPatterns = "/test")public class TestUpload extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String imgName = "table-test.png"; String imgPath = MediaUtil.getImgPath(); String imgFilePath = imgPath + "/" + imgName; byte[] buffer = new byte[1024 * 1024]; InputStream input = request.getInputStream(); OutputStream output = new FileOutputStream(imgFilePath); int bytesRead; while ((bytesRead = input.read(buffer)) != -1)&#123;// System.out.println(bytesRead); output.write(buffer, 0, bytesRead); &#125; output.close(); input.close(); response.getOutputStream().print(imgName); &#125;&#125; 三、浏览器根据文件名从服务器端获取图片Servlet的代码如下： 1234567891011121314151617181920212223242526package ctx.servlet;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class EditorChartServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String filename = request.getParameter("filename");if (filename == null) &#123; throw new ServletException("Parameter 'filename' must be supplied"); &#125; filename = ServletUtilities.searchReplace(filename, "..", ""); String imgPath = MediaUtil.getImgPath(); File file = new File(imgPath, filename); if (!(file.exists())) &#123; throw new ServletException("File '" + file.getAbsolutePath() + "' does not exist"); &#125; ServletUtilities.sendTempFile(file, response); &#125;&#125; 所用到的ServletUtil方法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public static String searchReplace(String inputString, String searchString, String replaceString) &#123; int i = inputString.indexOf(searchString); if (i == -1) &#123; return inputString; &#125; String r = ""; r = r + inputString.substring(0, i) + replaceString; if (i + searchString.length() &lt; inputString.length()) &#123; r = r + searchReplace(inputString.substring(i + searchString.length()), searchString, replaceString); &#125; return r; &#125;public static void sendTempFile(File file, HttpServletResponse response) throws IOException &#123; String mimeType = null; String filename = file.getName(); if (filename.length() &gt; 5) &#123; if (filename.substring(filename.length() - 5, filename.length()).equals(".jpeg")) &#123; mimeType = "image/jpeg"; &#125; else if (filename.substring(filename.length() - 4, filename.length()).equals(".png")) &#123; mimeType = "image/png"; &#125; &#125; sendTempFile(file, response, mimeType); &#125;public static void sendTempFile(File file, HttpServletResponse response, String mimeType) throws IOException &#123; if (file.exists()) &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file)); if (mimeType != null) &#123; response.setHeader("Content-Type", mimeType); &#125; response.setHeader("Content-Length", String.valueOf(file.length())); SimpleDateFormat sdf = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.ENGLISH); sdf.setTimeZone(TimeZone.getTimeZone("GMT")); response.setHeader("Last-Modified", sdf.format(new Date(file.lastModified()))); BufferedOutputStream bos = new BufferedOutputStream(response.getOutputStream()); byte[] input = new byte[1024]; boolean eof = false; while (!(eof)) &#123; int length = bis.read(input); if (length == -1) &#123; eof = true; &#125; else &#123; bos.write(input, 0, length); &#125; &#125; bos.flush(); bis.close(); bos.close(); &#125; else &#123; throw new FileNotFoundException(file.getAbsolutePath()); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
</search>
